Script started on Mon Feb 24 23:32:32 2014
sh-3.00$ pwd
/home/15/ajsnyde/cs2020rh
sh-3.00$ ls
a.out          file10000.txt  lab1c.cpp      lab1e.photo    lab3.cpp       wired.txt
file.txt       lab1a.cpp      lab1c.photo    lab2a.cpp      lab3.photo
file10.txt     lab1a.photo    lab1d.cpp      lab2a.photo    lab4.cpp
file100.txt    lab1b.cpp      lab1d.photo    lab2b.cpp      lab4.photo
file1000.txt   lab1b.photo    lab1e.cpp      lab2b.photo    lib
sh-3.00$ cat lab4.cpp
//All code by Addison Snyder
//2/24/2014
//lab4.cpp - struct program
#include <iostream>
#include <string>
#include <fstream>

using namespace std;

struct tile//struct definition
{
int id;
string type;
int color;
double chance;
double factor;
bool land;
};
//prototypes
void fill_array(tile[]);
void display(tile[]);
void search(tile[]);

const int MAX = 10; // size of struct array - NOT dependent on number of structs in file.
ifstream input;//creates input stream

int main()
{
        tile tile_type[MAX];
        fill_array(tile_type);
        display(tile_type);
        search(tile_type);
        return 0;
}

void fill_array(tile temptile[])//(attempts) to take data from "file.txt" and integrate it into the array of structs previously created in main()
{
        int i = 0;//used for designating which struct is getting data
        input.open("file.txt");//open file
        if(input.fail())//kills program if file not found or is otherwise inaccesible
        {
                cout << "Cannot open file! Terminating Program!\n";
                exit(1);//exits entire program with error code 1
        }
        else
                cout << "File loaded!\n";//success!

        input >> temptile[i].id;//seeding loop

        while(!input.eof())//stops at end of file. MAX still determines the actual max of entries, and could potentially write beyond the array's limit.
        {
                input >> temptile[i].type;
                input >> temptile[i].color;
                input >> temptile[i].chance;
                input >> temptile[i].factor;
                input >> temptile[i].land;
                i++;
                input >> temptile[i].id;
        }

// This loop also could have also worked, without the need to seed or worry about reading past the file
//      for(int i = 0; !input.eof(); i++)
//      {
//              input >> temptile[i].id;
//              input >> temptile[i].type;
//              input >> temptile[i].color;
//              input >> temptile[i].chance;
//              input >> temptile[i].factor;
//              input >> temptile[i].land;
//      }
        cout << "File loading complete!\n\n";
        return;
}

void display(tile temptile[])//displays all struct elements in a useful manner
{
        cout << "Displaying structs:\n";

        for(int i = 0; i < MAX; i++)//nothing special here
        {
                cout << "ID: " << temptile[i].id << "\n";
                cout << "Type: " << temptile[i].type << "\n";
                cout << "Color Code: " << temptile[i].color << "\n";
                cout << "Chance: " << temptile[i].chance << "\n";
                cout << "Chance Factor: " << temptile[i].factor << "\n";
                cout << "Land: " << temptile[i].land << "\n\n";
        }
        return;
}

void search(tile temptile[])
{
        int ID;
        cout << "Please enter an ID to search for: ";
        cin >> ID;
        cout << "ID: " << temptile[ID].id << "\n";
        cout << "Type: " << temptile[ID].type << "\n";
        cout << "Color Code: " << temptile[ID].color << "\n";
        cout << "Chance: " << temptile[ID].chance << "\n";
        cout << "Chance Factor: " << temptile[ID].factor << "\n";
        cout << "Land: " << temptile[ID].factor << "\n\n";
}sh-3.00$ cat file.txt
0
forest
31
100
1.5
1
1
plains
33
60
1.1
1
2
rocks
37
20
1.8
1
3
portal
35
10
0
1
4
water
35
50
3.5
0
5
pond
35
10
0
0
6
fortress
30
5
2
1
7
goblin
39
30
1.2
1
8
mountains
34
100
1.5
1
9
cave
34
40
1
1sh-3.00$ g++ lab4.cpp
lab4.cpp:102:2: warning: no newline at end of file
sh-3.00$ a.out
File loaded!
File loading complete!

Displaying structs:
ID: 0
Type: forest
Color Code: 31
Chance: 100
Chance Factor: 1.5
Land: 1

ID: 1
Type: plains
Color Code: 33
Chance: 60
Chance Factor: 1.1
Land: 1

ID: 2
Type: rocks
Color Code: 37
Chance: 20
Chance Factor: 1.8
Land: 1

ID: 3
Type: portal
Color Code: 35
Chance: 10
Chance Factor: 0
Land: 1

ID: 4
Type: water
Color Code: 35
Chance: 50
Chance Factor: 3.5
Land: 0

ID: 5
Type: pond
Color Code: 35
Chance: 10
Chance Factor: 0
Land: 0

ID: 6
Type: fortress
Color Code: 30
Chance: 5
Chance Factor: 2
Land: 1

ID: 7
Type: goblin
Color Code: 39
Chance: 30
Chance Factor: 1.2
Land: 1

ID: 8
Type: mountains
Color Code: 34
Chance: 100
Chance Factor: 1.5
Land: 1

ID: 9
Type: cave
Color Code: 34
Chance: 40
Chance Factor: 1
Land: 1

Please enter an ID to search for: 2
ID: 2
Type: rocks
Color Code: 37
Chance: 20
Chance Factor: 1.8
Land: 1.8

sh-3.00$ exit

script done on Mon Feb 24 23:33:27 2014
